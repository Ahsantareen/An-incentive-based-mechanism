#include <ilcplex/ilocplex.h>
ILOSTLBEGIN


int
main(int, char**)
{
	IloEnv env;

	try {

		int totaltime = 24;//One day
		float electricdemand[24] = { 193,201,203,189,199,222,371,389,378,526,604,575,587,554,556,556,555,499,429,363,291,258,230,60 };//Electicity demand w.r.t time
		float gridbuy[24] = { 100,90,90,90,90,90, 110, 110, 110, 110, 110, 125, 125, 125, 125, 125, 125, 125, 110, 110, 110, 110, 110, 110 };//buying price from grid w.r.t time
		float gridsell[24] = { 70, 70, 70, 70, 70, 70, 90,90,90,90,90, 105, 105,105,105,105,105,105,90,90,90,90,90,90 };//selling price to grid w.r.t time
		float pvpower[24] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 10,15,20,23,28,33,35,34,31,28,10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };//Power generated by PV w.r.t time
		int dg1cost = 80;//Cost for generating per kW power from dg
		int chp1cost = 105;//Cost for generating per kW power from chp
		int i;
		int t1 = 8;
		int t2 = 19;

		float socini = 0.2;//Initially charged battery
		int pbmax = 200;//battery maximum capacity
		float effin = 0.95;//battery effcienc



		IloModel model(env);
		IloNumVarArray Gridpowerbuy(env, totaltime, 0, IloInfinity);//Grid power bought
		IloNumVarArray Gridpowersell(env, totaltime, 0, IloInfinity);//Grid power sold
		IloNumVarArray Incentive(env, totaltime, 0, IloInfinity);//CHPA power generation range

		IloExpr solutio(env, totaltime);


		for (i = 0; i < totaltime; i++)
		{
			solutio += Incentive[i] * electricdemand[i] - IloPower(Incentive[i],2) * (gridbuy[i] - gridsell[i]);

		}
		// Objective: minimize cost
		model.add(IloMaximize(env, solutio));

		// Constraint: meet demand
		for (i = 0; i < totaltime; i++){

		model.add(0 <= Incentive[i]);
		model.add(Incentive[i] <= gridbuy[i] - gridsell[i]);

		if (i > t1 && i < t2)
		{
			model.add(Incentive[i] >= 0);
		}
		else
		{
			model.add(Incentive[i] == 0);
		}
	}


		IloCplex cplex(env);
		cplex.extract(model);
		cplex.exportModel("ModelLP.lp");

		cplex.solve();

		cout << "Solution status: " << cplex.getStatus() << endl;

		cout << "Minimized Objective Funtion " << cplex.getObjValue() << endl;

		cout << "DGA" << "   " << "CHPA" << "   " << "Grid" << "   " << "Grid power sell" << "   " << "PV" << "   " << "DEmand" << "   " << "SOC" << "   " << "charging" << "   " << "discharging" << endl;

		for (i = 0; i < totaltime; i++)
		{
			cout << cplex.getValue(Incentive[i]) << endl;
		}
		IloNum eps = cplex.getParam(
			IloCplex::Param::MIP::Tolerances::Integrality);
	}
	catch (IloException& ex) {
		cerr << "Error: " << ex << endl;
	}

	env.end();
	system("pause");
	return 0;
	}